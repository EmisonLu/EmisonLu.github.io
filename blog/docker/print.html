<!DOCTYPE HTML>
<html lang="zn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Docker.html"><strong aria-hidden="true">1.</strong> Docker</a></li><li class="chapter-item expanded "><a href="基本概念/基本概念.html"><strong aria-hidden="true">2.</strong> 基本概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="基本概念/镜像.html"><strong aria-hidden="true">2.1.</strong> 镜像</a></li><li class="chapter-item expanded "><a href="基本概念/容器.html"><strong aria-hidden="true">2.2.</strong> 容器</a></li><li class="chapter-item expanded "><a href="基本概念/仓库.html"><strong aria-hidden="true">2.3.</strong> 仓库</a></li></ol></li><li class="chapter-item expanded "><a href="安装Docker/安装Docker.html"><strong aria-hidden="true">3.</strong> 安装Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="安装Docker/镜像加速器.html"><strong aria-hidden="true">3.1.</strong> 镜像加速器</a></li></ol></li><li class="chapter-item expanded "><a href="使用镜像/使用镜像.html"><strong aria-hidden="true">4.</strong> 使用镜像</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="使用镜像/获取镜像.html"><strong aria-hidden="true">4.1.</strong> 获取镜像</a></li><li class="chapter-item expanded "><a href="使用镜像/列出镜像.html"><strong aria-hidden="true">4.2.</strong> 列出镜像</a></li><li class="chapter-item expanded "><a href="使用镜像/删除本地镜像.html"><strong aria-hidden="true">4.3.</strong> 删除本地镜像</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> 利用 commit 理解镜像构成</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Dockerfile</div></li></ol></li><li class="chapter-item expanded "><a href="操作容器/操作容器.html"><strong aria-hidden="true">5.</strong> 操作容器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="操作容器/启动.html"><strong aria-hidden="true">5.1.</strong> 启动</a></li><li class="chapter-item expanded "><a href="操作容器/守护态运行.html"><strong aria-hidden="true">5.2.</strong> 守护态运行</a></li><li class="chapter-item expanded "><a href="操作容器/终止.html"><strong aria-hidden="true">5.3.</strong> 终止</a></li><li class="chapter-item expanded "><a href="操作容器/进入容器.html"><strong aria-hidden="true">5.4.</strong> 进入容器</a></li><li class="chapter-item expanded "><a href="操作容器/导出和导入.html"><strong aria-hidden="true">5.5.</strong> 导出和导入</a></li><li class="chapter-item expanded "><a href="操作容器/删除.html"><strong aria-hidden="true">5.6.</strong> 删除</a></li></ol></li><li class="chapter-item expanded "><a href="数据管理/数据管理.html"><strong aria-hidden="true">6.</strong> 数据管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据管理/数据卷.html"><strong aria-hidden="true">6.1.</strong> 数据卷</a></li><li class="chapter-item expanded "><a href="数据管理/挂载主机目录.html"><strong aria-hidden="true">6.2.</strong> 挂载主机目录</a></li></ol></li><li class="chapter-item expanded "><a href="访问仓库/访问仓库.html"><strong aria-hidden="true">7.</strong> 访问仓库</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Docker Hub</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> 私有仓库</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Nexus3</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 使用网络</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> ...</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docker</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>基于 Linux 内核的<code>cgroup</code>、<code>namespace</code>，对进程进行封装隔离，是 OS 层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p>
<ul>
<li><code>runc</code>：Linux 命令行工具，根据 OCI 容器运行时规范创建和运行容器。</li>
<li><code>containerd</code>：守护程序，由于管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</li>
</ul>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h1>
<p>Docker 包括三个基本概念</p>
<ul>
<li>Image</li>
<li>Container</li>
<li>Repository</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="镜像"><a class="header" href="#镜像">镜像</a></h1>
<p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker Image，就相当于是一个 root 文件系统。比如官方 Image  ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p>
<p>Docker Image 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 Image 不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>因为 Image 包含 OS 完整的 root 文件系统，其体积往往是庞大的。因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，Image 并非是像一个 ISO 那样的打包文件， Image 只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>Image 构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随 Image 。因此，在构建 Image 的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得 Image 的复用、定制变的更为容易。甚至可以用之前构建好的 Image 作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的 Image 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器"><a class="header" href="#容器">容器</a></h1>
<p>Image 和 Container 的关系，就像是面向对象程序设计中的类和实例一样， Image 是静态的定义，Container 是 Image 运行时的实体。Container 可以被创建、启动、停止、删除、暂停等。</p>
<p>Container 的实质是进程，但与直接在宿主执行的进程不同，Container 进程运行于属于自己的独立的 namespace。因此 Container 可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。Container 内的进程是运行在一个隔离的环境里，使用起来就好像是在一个独立于宿主的系统下操作一样。这种特性使得 Container 封装的应用比直接在宿主运行更加安全。</p>
<p>Image 使用的是分层存储，Container 也是如此。每一个 Container 运行时，是以 Image 为基础层，在其上创建一个当前 Container 的存储层，可以称这个为 Container 运行时读写而准备的存储层为  Container 存储层。</p>
<p>Container 存储层的生存周期和 Container 一样，Container 消亡时，Container 存储层也随之消亡。因此，任何保存于 Container 存储层的信息都会随 Container 删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，Container 不应该向其存储层内写入任何数据，Container 存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume，或者绑定宿主目录，在这些位置的读写会跳过 Container 存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>Volume 的生存周期独立于 Container ， Container 消亡，数据卷不会消亡。因此，使用数据卷后，Container 删除或者重新运行之后，数据却不会丢失。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仓库"><a class="header" href="#仓库">仓库</a></h1>
<p>Image 构建完成后，可以很容易的在当前宿主机上运行，但是如果需要在其它服务器上使用这个 Image ，就需要一个集中的存储、分发 Image 的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个 Repository；每个 Repository 可以包含多个 Tag；每个 Tag 对应一个 Image。</p>
<p>通常，一个 Repository 会包含同一个软件不同版本的 Image ，而 Tag 就常用于对应该软件的各个版本。我们可以通过 <Repository>:<Tag> 的格式来指定具体是这个软件哪个版本的 Image。如果不给出 Tag，将以 latest 作为默认 Tag。</p>
<p>以 Ubuntu  Image 为例，ubuntu 是 Repository 的名字，其内包含有不同的版本 Tag，如16.04、18.04。可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的 Image 。如果忽略了 Tag，比如 ubuntu，那将视为 ubuntu:latest。</p>
<p>Repository 名经常以两段式路径形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-docker"><a class="header" href="#安装-docker">安装 Docker</a></h1>
<p><a href="https://docs.docker.com/get-docker/">安装指南</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="镜像加速器"><a class="header" href="#镜像加速器">镜像加速器</a></h1>
<p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。</p>
<ul>
<li><a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 右侧镜像工具 -&gt; 镜像加速器 -&gt; 复制加速器地址)</a></li>
<li><a href="https://www.163yun.com/help/documents/56918246390157312">网易云加速器 https://hub-mirror.c.163.com</a></li>
<li><a href="https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#%E4%BD%BF%E7%94%A8dockerhub%E5%8A%A0%E9%80%9F%E5%99%A8">百度云加速器 https://mirror.baidubce.com</a></li>
</ul>
<h2 id="ubuntu-1604debian-8centos-7"><a class="header" href="#ubuntu-1604debian-8centos-7">Ubuntu 16.04+、Debian 8+、CentOS 7+</a></h2>
<p>查看是否在 docker.service 文件中配置过镜像地址。</p>
<pre><code class="language-bash">$ systemctl cat docker | grep '\-\-registry\-mirror'
</code></pre>
<p>如果该命令有输出，那么执行 <code>systemctl cat docke</code>r 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p>
<p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p>
<pre><code class="language-json">{  
  &quot;registry-mirrors&quot;: [
  	&quot;https://hub-mirror.c.163.com&quot;,
  	&quot;https://mirror.baidubce.com&quot;  
	]
}
</code></pre>
<p>重新启动服务。</p>
<pre><code class="language-bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart docker
</code></pre>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<p>在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址。</p>
<pre><code class="language-json">{  
  &quot;registry-mirrors&quot;: [
  	&quot;https://hub-mirror.c.163.com&quot;,
  	&quot;https://mirror.baidubce.com&quot;  
	]
}
</code></pre>
<h2 id="check"><a class="header" href="#check">Check</a></h2>
<p>执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<pre><code class="language-bash">Registry Mirrors:
	https://hub-mirror.c.163.com/
</code></pre>
<h2 id="k8sgcrio"><a class="header" href="#k8sgcrio">k8s.gcr.io</a></h2>
<p>可以登录 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy">阿里云 容器镜像服务</a> 镜像中心 -&gt; 镜像搜索 查找。例如 <code>k8s.gcr.io/coredns:1.6.7</code> 镜像可以用 <code>registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7</code>代替。</p>
<p>一般情况下有如下对应关系：</p>
<pre><code class="language-bash"># docker pull k8s.gcr.io/xxx
$ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用镜像"><a class="header" href="#使用镜像">使用镜像</a></h1>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取镜像"><a class="header" href="#获取镜像">获取镜像</a></h1>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<pre><code class="language-bash">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
</code></pre>
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到。</p>
<ul>
<li>Registry 地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub(docker.io)。</li>
<li>仓库名：仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li>
</ul>
<pre><code class="language-bash">$ docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
92dc2a97ff99: Pull complete
be13a9d27eb8: Pull complete
c8299583700a: Pull complete
Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
Status: Downloaded newer image for ubuntu:18.04
docker.io/library/ubuntu:18.04
</code></pre>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （docker.io）获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。docker pull 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>有了镜像后，就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p>
<pre><code class="language-bash">$ docker run -it --rm ubuntu:18.04 bash

root@e7009c6ce357:/# cat /etc/os-release
NAME=&quot;Ubuntu&quot;
VERSION=&quot;18.04.1 LTS (Bionic Beaver)&quot;
ID=ubuntuID_LIKE=debian
PRETTY_NAME=&quot;Ubuntu 18.04.1 LTS&quot;
VERSION_ID=&quot;18.04&quot;
HOME_URL=&quot;https://www.ubuntu.com/&quot;
SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;
BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
</code></pre>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code> 交互式操作，一个是 <code>-t</code> 终端。这里为了进入 bash 执行一些命令并查看返回结果，因此需要交互式终端。</li>
<li><code>--rm</code>：容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是命令，这里希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，可以在 Shell 下操作，执行任何所需的命令。这里，执行了 <code>cat /etc/os-release</code>。最后通过 <code>exit</code> 退出这个容器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列出镜像"><a class="header" href="#列出镜像">列出镜像</a></h1>
<p>可以使用 <code>docker image ls</code> 命令，列出已经下载下来的镜像。</p>
<pre><code class="language-bash">$ docker image ls
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
nginx                latest              05a60462f8ba        5 days ago          181 MB
mongo                3.2                 fe9198c04d62        5 days ago          342 MB
&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB
ubuntu               18.04               329ed837d508        3 days ago          63.3MB
ubuntu               bionic              329ed837d508        3 days ago          63.3MB
</code></pre>
<p>镜像 ID 是镜像的唯一标识，一个镜像可以对应多个标签。在上面的例子中，可以看到 ubuntu:18.04 和 ubuntu:bionic 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p>有时候只希望列出部分镜像，<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像：</p>
<pre><code class="language-bash">$ docker image ls ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               329ed837d508        3 days ago          63.3MB
ubuntu              bionic              329ed837d508        3 days ago          63.3MB
</code></pre>
<p>列出特定的某个镜像，也就是指定仓库名和标签：</p>
<pre><code class="language-bash">$ docker image ls ubuntu:18.04
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               329ed837d508        3 days ago          63.3MB
</code></pre>
<p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。比如，倘若希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p>
<pre><code class="language-bash">$ docker image ls -f since=mongo:3.2
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
redis               latest              5f515359c7f8        5 days ago          183 MB
nginx               latest              05a60462f8ba        5 days ago          181 MB
</code></pre>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p>
<p>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤：</p>
<pre><code class="language-bash">$ docker image ls -f label=com.example.version=0.1...
</code></pre>
<h2 id="镜像大小"><a class="header" href="#镜像大小">镜像大小</a></h2>
<p>Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和。因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>可以通过 <code>docker system df</code> 命令来查看镜像、容器、数据卷所占用的空间。</p>
<pre><code class="language-bash">$ docker system df

TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              24                  0                   1.992GB             1.992GB (100%)
Containers          1                   0                   62.82MB             62.82MB (100%)
Local Volumes       9                   0                   652.2MB             652.2MB (100%)
Build Cache                                                 0B                  0B
</code></pre>
<h2 id="dangling-image"><a class="header" href="#dangling-image">Dangling Image</a></h2>
<p>上面的镜像列表中，可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>。</p>
<pre><code class="language-bash">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB
</code></pre>
<p>这个镜像原本是有镜像名和标签的，为 mongo:3.2。随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 dangling image，可以用下面的命令专门显示这类镜像：</p>
<pre><code class="language-bash">$ docker image ls -f dangling=true
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB
</code></pre>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<pre><code class="language-bash">$ docker image prune
</code></pre>
<h2 id="中间层镜像"><a class="header" href="#中间层镜像">中间层镜像</a></h2>
<p>为了加速镜像构建、重复利用资源，Docker 会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<pre><code class="language-bash">$ docker image ls -a
</code></pre>
<p>这样会看到很多无标签的镜像，与之前的 dangling image 不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h2 id="以特定格式显示"><a class="header" href="#以特定格式显示">以特定格式显示</a></h2>
<p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p>
<pre><code class="language-bash">$ docker image ls -q
5f515359c7f8
05a60462f8ba
fe9198c04d62
00285df0df87
329ed837d508
329ed837d508
</code></pre>
<p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来会在各个命令中看到这类搭配以完成很强大的功能。</p>
<p>另外一些时候，可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<pre><code class="language-bash">$ docker image ls --format &quot;{{.ID}}: {{.Repository}}&quot;
5f515359c7f8: redis
05a60462f8ba: nginx
fe9198c04d62: mongo
00285df0df87: &lt;none&gt;
329ed837d508: ubuntu
329ed837d508: ubuntu
</code></pre>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<pre><code class="language-bash">$ docker image ls --format &quot;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&quot;
IMAGE ID            REPOSITORY          TAG
5f515359c7f8        redis               latest
05a60462f8ba        nginx               latest
fe9198c04d62        mongo               3.2
00285df0df87        &lt;none&gt;              &lt;none&gt;
329ed837d508        ubuntu              18.04
329ed837d508        ubuntu              bionic
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="删除本地镜像"><a class="header" href="#删除本地镜像">删除本地镜像</a></h1>
<p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<pre><code class="language-bash">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]
</code></pre>
<p><code>&lt;镜像&gt;</code> 可以是镜像短 ID、镜像长 ID、镜像名、镜像摘要。</p>
<pre><code class="language-bash">$ docker image ls
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB
redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB
docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB
nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB
</code></pre>
<p>可以用镜像的完整 ID，也称为长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用短 ID 来删除镜像。<code>docker image ls</code> 默认列出的即为短 ID，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果要删除 redis:alpine 镜像，可以执行：</p>
<pre><code class="language-bash">$ docker image rm 501
Untagged: redis:alpine
Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d
Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7
Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b
Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23
Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa
Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3
Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7
</code></pre>
<p>也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p>
<pre><code class="language-bash">$ docker image rm centos
Untagged: centos:latest
Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a
Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38
</code></pre>
<p>更精确的是使用镜像摘要来删除镜像。</p>
<pre><code class="language-bash">$ docker image ls --digests
REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE
node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB

$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
</code></pre>
<p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批删除镜像。比如，需要删除所有仓库名为 redis 的镜像：</p>
<pre><code class="language-bash">$ docker image rm $(docker image ls -q redis)
</code></pre>
<p>或者删除所有在 mongo:3.2 之前的镜像：</p>
<pre><code class="language-bash">$ docker image rm $(docker image ls -q -f before=mongo:3.2)
</code></pre>
<h2 id="untagged-和-deleted"><a class="header" href="#untagged-和-deleted">Untagged 和 Deleted</a></h2>
<p>如果观察上面这几个命令的运行输出信息的话，可以发现删除行为分为两类，一类是 Untagged，另一类是 Deleted。之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的原因。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作容器"><a class="header" href="#操作容器">操作容器</a></h1>
<p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启动"><a class="header" href="#启动">启动</a></h1>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（exited）的容器重新启动。</p>
<h2 id="新建并启动"><a class="header" href="#新建并启动">新建并启动</a></h2>
<p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<pre><code class="language-bash">$ docker run ubuntu:18.04 /bin/echo 'Hello world'
Hello world
</code></pre>
<p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<pre><code class="language-bash">$ docker run -t -i ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/#
</code></pre>
<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p>
<pre><code class="language-bash">root@af8bae53bdd3:/# pwd
/
root@af8bae53bdd3:/# ls
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h2 id="启动已终止容器"><a class="header" href="#启动已终止容器">启动已终止容器</a></h2>
<p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（exited）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<pre><code class="language-bash">root@ba267838cc1b:/# ps
  PID TTY          TIME CMD
    1 ?        00:00:00 bash
   11 ?        00:00:00 ps
</code></pre>
<p>容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="守护态运行"><a class="header" href="#守护态运行">守护态运行</a></h1>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<pre><code class="language-bash">$ docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
hello world
hello world
hello world
hello world
</code></pre>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<pre><code class="language-bash">$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</code></pre>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面。</p>
<blockquote>
<p>注： 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
</blockquote>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<pre><code class="language-bash">$ docker container ls
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright
</code></pre>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<pre><code class="language-bash">$ docker container logs [container ID or NAMES]
hello world
hello world
hello world
. . .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="终止"><a class="header" href="#终止">终止</a></h1>
<p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<pre><code class="language-bash">$ docker container ls -a
CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
ba267838cc1b        ubuntu:18.04             &quot;/bin/bash&quot;            30 minutes ago      Exited (0) About a minute ago                       trusting_newton
</code></pre>
<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进入容器"><a class="header" href="#进入容器">进入容器</a></h1>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐使用后者。</p>
<h2 id="attach"><a class="header" href="#attach">attach</a></h2>
<p>下面示例展示如何使用 <code>docker attach</code> 命令。</p>
<pre><code class="language-bash">$ docker run -dit ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia

$ docker attach 243c
root@243c32535da7:/#
</code></pre>
<blockquote>
<p>如果从这个 stdin 中 exit，会导致容器的停止。</p>
</blockquote>
<h2 id="exec"><a class="header" href="#exec">exec</a></h2>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code>、<code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i -t</code> 参数一起使用时，则可以看到 Linux 命令提示符。</p>
<pre><code class="language-bash">$ docker run -dit ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles

$ docker exec -i 69d1 bash
ls
bin
boot
dev
...

$ docker exec -it 69d1 bash
root@69d137adef7a:/#
</code></pre>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导出和导入"><a class="header" href="#导出和导入">导出和导入</a></h1>
<h2 id="导出容器"><a class="header" href="#导出容器">导出容器</a></h2>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<pre><code class="language-bash">$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test
$ docker export 7691a814370e &gt; ubuntu.tar
</code></pre>
<p>这样将导出容器快照到本地文件。</p>
<h2 id="导入容器快照"><a class="header" href="#导入容器快照">导入容器快照</a></h2>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如：</p>
<pre><code class="language-bash">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0
$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB
</code></pre>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p>
<pre><code class="language-bash">$ docker import http://example.com/exampleimage.tgz example/imagerepo
</code></pre>
<blockquote>
<p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="删除"><a class="header" href="#删除">删除</a></h1>
<h2 id="删除容器"><a class="header" href="#删除容器">删除容器</a></h2>
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如：</p>
<pre><code class="language-bash">$ docker container rm trusting_newton
trusting_newton
</code></pre>
<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<h2 id="清理所有处于终止状态的容器"><a class="header" href="#清理所有处于终止状态的容器">清理所有处于终止状态的容器</a></h2>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<pre><code class="language-bash">$ docker container prune
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据管理"><a class="header" href="#数据管理">数据管理</a></h1>
<p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据卷"><a class="header" href="#数据卷">数据卷</a></h1>
<p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h2 id="创建一个数据卷"><a class="header" href="#创建一个数据卷">创建一个数据卷</a></h2>
<pre><code class="language-bash">$ docker volume create my-vol
</code></pre>
<p>查看所有的数据卷：</p>
<pre><code class="language-bash">$ docker volume ls

DRIVER              VOLUME NAME
local               my-vol
</code></pre>
<p>在主机里使用以下命令可以查看指定数据卷的信息：</p>
<pre><code class="language-bash">$ docker volume inspect my-vol
[
    {
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<h2 id="启动一个挂载数据卷的容器"><a class="header" href="#启动一个挂载数据卷的容器">启动一个挂载数据卷的容器</a></h2>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个数据卷。</p>
<p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 /usr/share/nginx/html 目录。</p>
<pre><code class="language-bash">$ docker run -d -P \
    --name web \
    # -v my-vol:/usr/share/nginx/html \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<h2 id="查看数据卷的具体信息"><a class="header" href="#查看数据卷的具体信息">查看数据卷的具体信息</a></h2>
<p>在主机里使用以下命令可以查看 web 容器的信息：</p>
<pre><code class="language-bash">$ docker inspect web
</code></pre>
<p>数据卷信息在 &quot;Mounts&quot; Key 下面：</p>
<pre><code class="language-bash">&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
</code></pre>
<h2 id="删除数据卷"><a class="header" href="#删除数据卷">删除数据卷</a></h2>
<pre><code class="language-bash">$ docker volume rm my-vol
</code></pre>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理使用以下命令：</p>
<pre><code class="language-bash">$ docker volume prune
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="挂载主机目录"><a class="header" href="#挂载主机目录">挂载主机目录</a></h1>
<h2 id="挂载一个主机目录作为数据卷"><a class="header" href="#挂载一个主机目录作为数据卷">挂载一个主机目录作为数据卷</a></h2>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<pre><code class="language-bash">$ docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<p>上面的命令加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html 目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是读写，用户也可以通过增加 readonly 指定为只读。</p>
<pre><code class="language-bash">$ docker run -d -P \
    --name web \
    # -v /src/webapp:/usr/share/nginx/html:ro \
    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
    nginx:alpine
</code></pre>
<p>加了 readonly 之后，就挂载为只读了。如果在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误：</p>
<pre><code class="language-bash">/usr/share/nginx/html # touch new.txt
touch: new.txt: Read-only file system
</code></pre>
<h2 id="挂载一个本地主机文件作为数据卷"><a class="header" href="#挂载一个本地主机文件作为数据卷">挂载一个本地主机文件作为数据卷</a></h2>
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中。</p>
<pre><code class="language-bash">$ docker run --rm -it \
   # -v $HOME/.bash_history:/root/.bash_history \
   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \
   ubuntu:18.04 \
   bash

root@2affd44b4667:/# history
1  ls
2  diskutil list
</code></pre>
<p>这样就可以记录在容器输入过的命令了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问仓库"><a class="header" href="#访问仓库">访问仓库</a></h1>
<p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 docker.io/ubuntu 来说，docker.io 是注册服务器地址，ubuntu 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
